/*思路：此题最关键的就是该数组是一个排序数组，这就导致我们不用使用双重循环。
我们只需要采取两个索引i, j。i在前，j在后。只需要比较i, j两个位置的值，如果相等，
就不需要做其他事情，如果不相等，就需要把j位置的值复制到前面去（复制到i + 1位置），
因为不相等的时候，i, j都是我们需要保留的值，如果复制到i + 1中，这样就只有两种情况，
1：i和j之间没有值，也就是i j指向相邻位置，这个时候i + 1就是j这样复制就相当于没有变化。
2：i和j之间有值，这个时候，导致i, j之间有值是因为我们遇到i, j相等的情况就单纯的将j + 1
所以中间的值全部都是和i中的值一样的，这个时候将j中的值复制到i + 1就会覆盖一个和i相同的值，
这样就达到了目的。
*/
class Solution {
public:
	int removeDuplicates(vector<int>& nums) {
		if (nums.size() == 0) return 0;
		int i = 0;
		int j = 1;
		for (; j < nums.size(); ++j)
			if (nums[i] != nums[j])
				nums[++i] = nums[j];
		return i + 1;
	}
};
